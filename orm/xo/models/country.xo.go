package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// Country represents a row from 'public.country'.
type Country struct {
	Code           string          `json:"code" db:"code"`                     // code
	Name           string          `json:"name" db:"name"`                     // name
	Continent      string          `json:"continent" db:"continent"`           // continent
	Region         string          `json:"region" db:"region"`                 // region
	Surfacearea    float32         `json:"surfacearea" db:"surfacearea"`       // surfacearea
	Indepyear      sql.NullInt64   `json:"indepyear" db:"indepyear"`           // indepyear
	Population     int             `json:"population" db:"population"`         // population
	Lifeexpectancy sql.NullFloat64 `json:"lifeexpectancy" db:"lifeexpectancy"` // lifeexpectancy
	Gnp            sql.NullFloat64 `json:"gnp" db:"gnp"`                       // gnp
	Gnpold         sql.NullFloat64 `json:"gnpold" db:"gnpold"`                 // gnpold
	Localname      string          `json:"localname" db:"localname"`           // localname
	Governmentform string          `json:"governmentform" db:"governmentform"` // governmentform
	Headofstate    sql.NullString  `json:"headofstate" db:"headofstate"`       // headofstate
	Capital        sql.NullInt64   `json:"capital" db:"capital"`               // capital
	Code2          string          `json:"code2" db:"code2"`                   // code2
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the Country exists in the database.
func (c *Country) Exists() bool {
	return c._exists
}

// Deleted returns true when the Country has been marked for deletion from
// the database.
func (c *Country) Deleted() bool {
	return c._deleted
}

// Insert inserts the Country to the database.
func (c *Country) Insert(ctx context.Context, db DB) error {
	switch {
	case c._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case c._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.country (` +
		`code, name, continent, region, surfacearea, indepyear, population, lifeexpectancy, gnp, gnpold, localname, governmentform, headofstate, capital, code2` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15` +
		`)`
	// run
	logf(sqlstr, c.Code, c.Name, c.Continent, c.Region, c.Surfacearea, c.Indepyear, c.Population, c.Lifeexpectancy, c.Gnp, c.Gnpold, c.Localname, c.Governmentform, c.Headofstate, c.Capital, c.Code2)
	if _, err := db.ExecContext(ctx, sqlstr, c.Code, c.Name, c.Continent, c.Region, c.Surfacearea, c.Indepyear, c.Population, c.Lifeexpectancy, c.Gnp, c.Gnpold, c.Localname, c.Governmentform, c.Headofstate, c.Capital, c.Code2); err != nil {
		return logerror(err)
	}
	// set exists
	c._exists = true
	return nil
}

// Update updates a Country in the database.
func (c *Country) Update(ctx context.Context, db DB) error {
	switch {
	case !c._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case c._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.country SET ` +
		`name = $1, continent = $2, region = $3, surfacearea = $4, indepyear = $5, population = $6, lifeexpectancy = $7, gnp = $8, gnpold = $9, localname = $10, governmentform = $11, headofstate = $12, capital = $13, code2 = $14 ` +
		`WHERE code = $15`
	// run
	logf(sqlstr, c.Name, c.Continent, c.Region, c.Surfacearea, c.Indepyear, c.Population, c.Lifeexpectancy, c.Gnp, c.Gnpold, c.Localname, c.Governmentform, c.Headofstate, c.Capital, c.Code2, c.Code)
	if _, err := db.ExecContext(ctx, sqlstr, c.Name, c.Continent, c.Region, c.Surfacearea, c.Indepyear, c.Population, c.Lifeexpectancy, c.Gnp, c.Gnpold, c.Localname, c.Governmentform, c.Headofstate, c.Capital, c.Code2, c.Code); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Country to the database.
func (c *Country) Save(ctx context.Context, db DB) error {
	if c.Exists() {
		return c.Update(ctx, db)
	}
	return c.Insert(ctx, db)
}

// Upsert performs an upsert for Country.
func (c *Country) Upsert(ctx context.Context, db DB) error {
	switch {
	case c._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.country (` +
		`code, name, continent, region, surfacearea, indepyear, population, lifeexpectancy, gnp, gnpold, localname, governmentform, headofstate, capital, code2` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15` +
		`)` +
		` ON CONFLICT (code) DO ` +
		`UPDATE SET ` +
		`name = EXCLUDED.name, continent = EXCLUDED.continent, region = EXCLUDED.region, surfacearea = EXCLUDED.surfacearea, indepyear = EXCLUDED.indepyear, population = EXCLUDED.population, lifeexpectancy = EXCLUDED.lifeexpectancy, gnp = EXCLUDED.gnp, gnpold = EXCLUDED.gnpold, localname = EXCLUDED.localname, governmentform = EXCLUDED.governmentform, headofstate = EXCLUDED.headofstate, capital = EXCLUDED.capital, code2 = EXCLUDED.code2 `
	// run
	logf(sqlstr, c.Code, c.Name, c.Continent, c.Region, c.Surfacearea, c.Indepyear, c.Population, c.Lifeexpectancy, c.Gnp, c.Gnpold, c.Localname, c.Governmentform, c.Headofstate, c.Capital, c.Code2)
	if _, err := db.ExecContext(ctx, sqlstr, c.Code, c.Name, c.Continent, c.Region, c.Surfacearea, c.Indepyear, c.Population, c.Lifeexpectancy, c.Gnp, c.Gnpold, c.Localname, c.Governmentform, c.Headofstate, c.Capital, c.Code2); err != nil {
		return logerror(err)
	}
	// set exists
	c._exists = true
	return nil
}

// Delete deletes the Country from the database.
func (c *Country) Delete(ctx context.Context, db DB) error {
	switch {
	case !c._exists: // doesn't exist
		return nil
	case c._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.country ` +
		`WHERE code = $1`
	// run
	logf(sqlstr, c.Code)
	if _, err := db.ExecContext(ctx, sqlstr, c.Code); err != nil {
		return logerror(err)
	}
	// set deleted
	c._deleted = true
	return nil
}

// CountryByCode retrieves a row from 'public.country' as a Country.
//
// Generated from index 'country_pkey'.
func CountryByCode(ctx context.Context, db DB, code string) (*Country, error) {
	// query
	const sqlstr = `SELECT ` +
		`code, name, continent, region, surfacearea, indepyear, population, lifeexpectancy, gnp, gnpold, localname, governmentform, headofstate, capital, code2 ` +
		`FROM public.country ` +
		`WHERE code = $1`
	// run
	logf(sqlstr, code)
	c := Country{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, code).Scan(&c.Code, &c.Name, &c.Continent, &c.Region, &c.Surfacearea, &c.Indepyear, &c.Population, &c.Lifeexpectancy, &c.Gnp, &c.Gnpold, &c.Localname, &c.Governmentform, &c.Headofstate, &c.Capital, &c.Code2); err != nil {
		return nil, logerror(err)
	}
	return &c, nil
}

// City returns the City associated with the Country's (Capital).
//
// Generated from foreign key 'country_capital_fkey'.
func (c *Country) City(ctx context.Context, db DB) (*City, error) {
	return CityByID(ctx, db, int(c.Capital.Int64))
}
